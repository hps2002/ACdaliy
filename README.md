# huangpeishen的刷题日记
## 01背包
01背包就是对于n个物品以及1个背包，其中n个物品中，每个物品的重量为weight[i]，价值为value[i]，背包的容量为V, 且每个物品只能选一次。

一般有两种问题：
问背包能装下的最大价值为多少 ？
问装满V的方案数有多少？

### 求背包能装下的最大价值
使用二维的状态进行表示：dp[i][j]，表示在前i个物品中选，背包容量为j时背包能装的最大价值

对每个物品都进行挑选，每个物品都可以选，也可以不选，选的时候就要加上背包容量为 j - weight[i] 时能装的最大价值，然后和不选这个物品的情况进行比较，取最大值。
（这里是我最难理解的地方，所以还是需要多点做题，进行印象加深）

核心代码实现：(伪代码)
```
int dp[n][V + 1];
// 初始化
dp[0][0] = 0;
for (int i = wieght[0]; i <= V; i++)
    dp[0][i] = weight[0];

for (int i = 1; i < n; i++)
    for (int j = 0; j <= V; j++)
        if (wieght[i] > j) dp[i][j] = dp[i - 1][j];//这里因为当前i
        else dp[i][j] = max(dp[i - 1][j], dp[i - 1][j - weight[i]] + value[i]);

cout << dp[n - 1][V];//此时最大

```

因为二维的状态表示基本上都是从上一层进行拷贝，所以可以将状态压缩成一维的状态量。
状态方程是dp[j] = max(dp[j], dp[j - weight[i]] + value[i])
含义是在[0 - i]个物品中选，选出在背包容量为j的时候背包所能装下的最大的价值。

核心代码：
```
/**初始化是一样的**/
for (int i = 1; i < n; i++)
    for (int j = V; v >= werght[i]; j --)
        dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
```
上面的代码用用的时倒序遍历V，目的是避免重复遍历上一层同一个状态
比如：
i = 1， 且wieght[1] = 1的时候,正序遍历
dp[1] = max(dp[1], dp[1 - weight[1]] + value[1]);
dp[2] = max(dp[2], dp[2 - weight[1]] + value[2]);

此时我们发现，正序遍历的dp[2]加上的正是dp[1]刚刚更新的值，所以我们进行倒序遍历的话就能在dp[1]更新之前获取上一层的值。

但是为什么使用二维状态记录的时候，正序就可以完成问题的解答？
因为使用二位的时候dp[i][j] = max(dp[i - 1], dp[i - 1][j - weight[i]] + value[i]);，直接使用的时上一层的值，而上一层的值并不会受到正序遍历的影响。


01背包初始化

01背包初始化要视情况而定，初始化第0个物品的时候需要对于所有背包空间大于等于第0个物品的时候需要初始化为第0个物品的价值，因为此时的背包空间大于等于第0个物品所占用的空间，所以当前能装的最大价值为第0个物品的价值。

### 求装满背包的方案数
背包容量为j, 每个元素容量为nums[i]，求装满j的方案数
dp[j] += dp[j - nums[i]]

dp[j]的在循环中的含义是，前i个元素中装满容量为j的背包的方案数。

因此公式的含义是，下一个nums[i]的循环中刚好装满j容量的方案数等于刚好装满j - nums[i]的方案数。当计算到所有元素的时候，dp[n][j]就是前 n 个元素中能装满容量为j的背包的方案数。

但是为什么要使用 += 进行答案的搜索呢？
因为在j + 1的时候需要加上对不同的num[i]进行组合都有不同的方案数，所以要加上。
比如说：
i = 2, nums[2] = 1, dp[4] = 2, dp[2] = 2,此时dp[4]应该更新为dp[4]' = dp[4] + dp[2];
i = 3, nums[3] = 2, dp[4] = 2, dp[1] = 1,此时dp[4]应该更新为dp[4]'' = dp[4]' + dp[1];

核心代码：
```
//初始化
dp[0] = 1;

for (int i = 0; i < n; i++)
    for (int j = m; j >= nums[i]; j --)
        dp[j] += dp[j - nums[i]];
cout << dp[m];//为刚好装满不同组合的方案数
```
使用这个方法的物品重量必须是一
### 刷题日记
